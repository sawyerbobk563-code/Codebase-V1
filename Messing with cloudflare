<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SwiftChat - Secure & Anonymous</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- CryptoJS for encryption -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    
    <!-- PWA Manifest with Updated Icon -->
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIlN3aWZ0Q2hhdCIsCiAgInNob3J0X25hbWUiOiAiU3dpZnRDaGF0IiwKICAiZGVzY3JpcHRpb24iOiAiU2VjdXJlICYgQW5vbnltb3VzIFJlYWwtdGltZSBDaGF0IiwKICAic3RhcnRfdXJsIjogIi4iLAogICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLAogICJiYWNrZ3JvdW5kX2NvbG9yIjogIiMxMTExMTEiLAogICJ0aGVtZV9jb2xvciI6ICIjMDA3MGYzIiwKICAiaWNvbnMiOiBbCiAgICB7CiAgICAgICJzcmMiOiAiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2Zhdmljb25raXQvZW1vamkvNDAzL3BhY2tlci9uZXV0cmFsLzI1Ni9zcGVlY2hfYmFsbG9vbi5wbmciLAogICAgICAic2l6ZXMiOiAiMTkyeDE5MiIsCiAgICAgICJ0eXBlIjogImltYWdlL3BuZyIsCiAgICAgICJwdXJwb3NlIjogImFueSBtYXNrYWJsZSIKICAgIH0sCiAgICB7CiAgICAgICJzcmMiOiAiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2Zhdmljb25raXQvZW1vamkvNDAzL3BhY2tlci9uZXV0cmFsLzUxMi9zcGVlY2hfYmFsbG9vbi5wbmciLAogICAgICAic2l6ZXMiOiAiNTEyeDUxMiIsCiAgICAgICJ0eXBlIjogImltYWdlL3BuZyIsCiAgICAgICJwdXJwb3NlIjogImFueSBtYXNrYWJsZSIKICAgIH0KICBdCn0=">
    <link rel="icon" href="https://cdn.jsdelivr.net/gh/faviconkit/emoji/403/packer/neutral/256/speech_balloon.png">
    
    <script>
        tailwind.config = { darkMode: 'class' }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; transition: background-color 0.3s ease; }
        .chat-container { height: calc(100vh - 240px); }
        .message-bubble { max-width: 85%; transition: transform 0.1s; user-select: none; -webkit-touch-callout: none; }
        .message-bubble:active { transform: scale(0.98); }
        .emoji-panel { 
            display: none; 
            position: absolute; 
            bottom: 100%; 
            right: 0; 
            margin-bottom: 10px; 
            width: 260px; 
            max-height: 300px;
            overflow-y: auto;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        .emoji-panel.active { 
            display: grid; 
            opacity: 1;
            transform: translateY(0);
        }
        .context-menu { display: none; position: fixed; z-index: 100; }
        .context-menu.active { display: block; }
        
        /* Emoji spacing fix */
        .emoji { display: inline-block; margin: 0 1px; vertical-align: middle; }
        .message-text { word-break: break-word; }
        
        /* PWA Install Prompt */
        .pwa-install-prompt {
            position: fixed;
            bottom: 100px;
            right: 20px;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }
        
        .rate-limit-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.5rem;
            color: white;
            font-weight: bold;
            backdrop-filter: blur(2px);
        }
        
        .encryption-indicator {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            font-size: 10px;
            color: #10b981;
            background: rgba(16, 185, 129, 0.1);
            padding: 1px 4px;
            border-radius: 4px;
            margin-left: 4px;
        }
        
        .emoji-category-btn {
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 6px;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .emoji-category-btn.active {
            background: #3b82f6;
            color: white;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* Scrollbar styling for emoji panel */
        .emoji-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        .emoji-panel::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        .emoji-panel::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }
        
        .emoji-panel.dark::-webkit-scrollbar-track {
            background: #2d3748;
        }
        
        .emoji-panel.dark::-webkit-scrollbar-thumb {
            background: #4a5568;
        }
    </style>
</head>
<body class="flex flex-col h-screen overflow-hidden bg-slate-50 dark:bg-slate-950 text-slate-900 dark:text-slate-100">

    <!-- PWA Install Prompt -->
    <div id="pwa-prompt" class="pwa-install-prompt hidden">
        <div class="bg-white dark:bg-slate-800 border border-slate-300 dark:border-slate-700 rounded-xl shadow-2xl p-4 max-w-xs">
            <div class="flex items-center gap-3 mb-3">
                <img src="https://cdn.jsdelivr.net/gh/faviconkit/emoji/403/packer/neutral/96/speech_balloon.png" alt="SwiftChat" class="w-12 h-12">
                <div>
                    <h3 class="font-bold text-slate-900 dark:text-white">Install SwiftChat</h3>
                    <p class="text-sm text-slate-600 dark:text-slate-400">Use app offline</p>
                </div>
            </div>
            <div class="flex gap-2">
                <button onclick="dismissPWA()" class="flex-1 py-2 px-3 text-sm border border-slate-300 dark:border-slate-600 rounded-lg hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors">Not Now</button>
                <button onclick="installPWA()" class="flex-1 py-2 px-3 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-500 transition-colors">Install</button>
            </div>
        </div>
    </div>

    <!-- Context Menu Overlay -->
    <div id="context-menu" class="context-menu bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl shadow-2xl p-2 min-w-[140px] animate-in fade-in zoom-in duration-100">
        <div id="reaction-tools" class="flex gap-2 p-2 border-b border-slate-100 dark:border-slate-700 mb-1">
            <button onclick="addReaction('‚ù§Ô∏è')" class="hover:scale-125 transition-transform text-lg">‚ù§Ô∏è</button>
            <button onclick="addReaction('üòÇ')" class="hover:scale-125 transition-transform text-lg">üòÇ</button>
            <button onclick="addReaction('üòÆ')" class="hover:scale-125 transition-transform text-lg">üòÆ</button>
            <button onclick="addReaction('üî•')" class="hover:scale-125 transition-transform text-lg">üî•</button>
            <button onclick="addReaction('üëç')" class="hover:scale-125 transition-transform text-lg">üëç</button>
        </div>
        <button id="delete-btn" onclick="deleteMessage()" class="w-full text-left px-3 py-2 text-sm text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 rounded-lg flex items-center gap-2">
            <i data-lucide="trash-2" class="w-4 h-4"></i> Delete Message
        </button>
    </div>

    <header class="p-4 border-b border-slate-200 dark:border-slate-800 bg-white dark:bg-slate-900/50 backdrop-blur-md">
        <div class="flex justify-between items-center mb-2">
            <div class="flex items-center gap-2">
                <div class="bg-blue-600 p-1.5 rounded-lg shadow-lg">
                    <i data-lucide="zap" class="w-5 h-5 text-white"></i>
                </div>
                <h1 class="text-xl font-bold tracking-tight">SwiftChat</h1>
                <span class="encryption-indicator">
                    <i data-lucide="lock" class="w-3 h-3"></i>
                    <span>Encrypted</span>
                </span>
            </div>
            <div class="flex items-center gap-2">
                <button onclick="load()" class="p-2 rounded-full hover:bg-slate-200 dark:hover:bg-slate-800 transition-colors" title="Refresh">
                    <i data-lucide="rotate-cw" class="w-5 h-5"></i>
                </button>
                <button onclick="toggleTheme()" class="p-2 rounded-full hover:bg-slate-200 dark:hover:bg-slate-800 transition-colors">
                    <i id="theme-icon" data-lucide="moon" class="w-5 h-5"></i>
                </button>
                <div class="flex items-center gap-2 text-xs text-slate-500 border-l border-slate-200 dark:border-slate-800 pl-3">
                    <span id="status-dot" class="w-2 h-2 rounded-full bg-green-500"></span>
                </div>
            </div>
        </div>
        <div class="flex items-center gap-2 px-3 py-1.5 bg-slate-200 dark:bg-slate-800/50 rounded-lg w-fit border border-slate-300 dark:border-slate-700/50">
            <i data-lucide="globe" class="w-3.5 h-3.5 text-blue-500"></i>
            <span id="ip-display" class="text-xs font-mono text-blue-600 dark:text-blue-300">Fetching IP...</span>
        </div>
    </header>

    <main id="chat" class="flex-1 overflow-y-auto p-4 space-y-4 chat-container"></main>

    <footer class="p-4 bg-white dark:bg-slate-900 border-t border-slate-200 dark:border-slate-800">
        <div class="max-w-4xl mx-auto space-y-3">
            <div class="flex gap-2 relative">
                <input id="userInput" type="text" placeholder="Alias" class="w-24 bg-slate-100 dark:bg-slate-800 border border-slate-300 dark:border-slate-700 rounded-lg py-2 px-2 text-sm focus:outline-none">
                <div class="relative flex-grow">
                    <input id="textInput" type="text" placeholder="Type your encrypted message..." class="w-full bg-slate-100 dark:bg-slate-800 border border-slate-300 dark:border-slate-700 rounded-lg py-2 px-4 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500" onkeypress="handleKeyPress(event)">
                    <div id="rate-limit-overlay" class="rate-limit-overlay hidden">
                        <div class="text-center">
                            <div class="text-lg">‚è≥</div>
                            <div class="text-xs mt-1">Wait 3s</div>
                        </div>
                    </div>
                </div>
                <div class="relative">
                    <button onclick="toggleEmojis()" id="emoji-btn" class="bg-slate-100 dark:bg-slate-800 border border-slate-300 dark:border-slate-700 p-2 rounded-lg hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors">
                        <i data-lucide="smile" class="w-5 h-5"></i>
                    </button>
                    <div id="emoji-panel" class="emoji-panel bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl shadow-2xl z-50">
                        <!-- Categories will be populated by JavaScript -->
                    </div>
                </div>
                <button onclick="send()" id="send-btn" class="bg-blue-600 hover:bg-blue-500 text-white px-4 rounded-lg flex items-center justify-center"><i data-lucide="send" class="w-5 h-5"></i></button>
            </div>
        </div>
    </footer>

    <script>
        const WORKER_URL = "https://swiftchat.sawyerbobk563.workers.dev/";
        const room = "general";
        let lastMessageCount = 0;
        let selectedMessageId = null;
        let longPressTimer;
        let deferredPrompt = null;
        let lastSentTime = 0;
        const MESSAGE_COOLDOWN = 3000; // 3 seconds in milliseconds
        
        // Encryption settings
        const ENCRYPTION_ENABLED = true;
        let encryptionKey = null;
        const ENCRYPTION_KEY_STORAGE = "swiftchat_encryption_key";
        
        // Emoji categories
        const emojiCategories = {
            "Smileys": ['üòÄ','üòÅ','üòÇ','ü§£','üòÉ','üòÑ','üòÖ','üòÜ','üòâ','üòä','üòã','üòé','üòç','üòò','ü•∞','üòó','üòô','üòö','üôÇ','ü§ó','ü§©','ü§î','ü§®','üòê','üòë','üò∂','üôÑ','üòè','üò£','üò•','üòÆ','ü§ê','üòØ','üò™','üò´','ü•±','üò¥','üòå','üòõ','üòú','üòù','ü§§','üòí','üòì','üòî','üòï','üôÉ','ü´†','ü´¢','ü´£','ü§™','üò≤','ü•∫','ü•π'],
            "Gestures": ['üëã','ü§ö','üñêÔ∏è','‚úã','üññ','üëå','ü§å','ü§è','‚úåÔ∏è','ü§û','ü´∞','ü§ü','ü§ò','ü§ô','ü´µ','üëà','üëâ','üëÜ','üñï','üëá','‚òùÔ∏è','üëç','üëé','‚úä','üëä','ü§õ','ü§ú','üëè','üôå','ü´∂','üëê','ü§≤','ü§ù','üôè'],
            "Hearts": ['‚ù§Ô∏è','üß°','üíõ','üíö','üíô','üíú','üñ§','ü§ç','ü§é','üíî','‚ù£Ô∏è','üíï','üíû','üíì','üíó','üíñ','üíò','üíù','üíü'],
            "Objects": ['üí°','üì±','üíª','‚å®Ô∏è','üñ•Ô∏è','üñ®Ô∏è','üñ±Ô∏è','üñ≤Ô∏è','üéß','üé§','üéÆ','üïπÔ∏è','üì∑','üé•','üìΩÔ∏è','üéûÔ∏è','üìû','‚òéÔ∏è','üìü','üì†','üì∫','üìª','üéôÔ∏è','üéöÔ∏è','üéõÔ∏è','üß≠'],
            "Symbols": ['üî£','‚ûï','‚ûñ','‚ûó','‚úñÔ∏è','üí≤','üí±','‚Ñ¢Ô∏è','¬©Ô∏è','¬ÆÔ∏è','„Ä∞Ô∏è','‚û∞','‚ûø','üîö','üîô','üîõ','üîù','üîú'],
            "Nature": ['üê∂','üê±','üê≠','üêπ','üê∞','ü¶ä','üêª','üêº','üê®','üêØ','ü¶Å','üêÆ','üê∑','üê∏','üêµ','üôà','üôâ','üôä','üêí','üêî','üêß','üê¶','üê§','üê£','üê•','ü¶Ü','ü¶Ö','ü¶â','ü¶á','üê∫','üêó','üê¥','ü¶Ñ','üêù','ü™±','üêõ','ü¶ã','üêå','üêû','üêú','ü™∞','ü™≤','ü™≥','ü¶ü','ü¶ó','üï∑Ô∏è','üï∏Ô∏è','ü¶Ç'],
            "Food": ['üçè','üçé','üçê','üçä','üçã','üçå','üçâ','üçá','üçì','ü´ê','üçà','üçí','üçë','ü•≠','üçç','ü••','ü•ù','üçÖ','üçÜ','ü•ë','ü•¶','ü•¨','ü•í','üå∂Ô∏è','ü´ë','üåΩ','ü•ï','ü´í','üßÑ','üßÖ','ü•î','üç†','ü´ò','ü•ê','ü•Ø','üçû','ü•ñ','ü•®','üßÄ','ü•ö','üç≥','üßà','ü•û','üßá','ü•ì','ü•©','üçó','üçñ','ü¶¥','üå≠','üçî','üçü','üçï'],
            "Travel": ['üöó','üöï','üöô','üöå','üöé','üèéÔ∏è','üöì','üöë','üöí','üöê','üõª','üöö','üöõ','üöú','ü¶Ø','ü¶Ω','ü¶º','üõ¥','üö≤','üõµ','üèçÔ∏è','üõ∫','üö®','üöî','üöç','üöò','üöñ','üö°','üö†','üöü','üöÉ','üöã','üöû','üöù','üöÑ','üöÖ','üöà','üöÇ','üöÜ','üöá','üöä','üöâ','‚úàÔ∏è','üõ´','üõ¨','üõ©Ô∏è','üí∫','üõ∞Ô∏è','üöÄ','üõ∏','üöÅ','üõ∂','‚õµ','üö§','üõ•Ô∏è','üõ≥Ô∏è','‚õ¥Ô∏è','üö¢']
        };

        function initIcons() { lucide.createIcons(); }
        initIcons();

        // Initialize Emoji Picker
        function initEmojiPicker() {
            const emojiPanel = document.getElementById('emoji-panel');
            emojiPanel.innerHTML = '';
            
            // Create category buttons
            const categoryContainer = document.createElement('div');
            categoryContainer.className = 'flex gap-1 p-2 border-b border-slate-200 dark:border-slate-700 overflow-x-auto';
            
            Object.keys(emojiCategories).forEach((category, index) => {
                const btn = document.createElement('button');
                btn.className = `emoji-category-btn ${index === 0 ? 'active' : 'bg-slate-100 dark:bg-slate-700 text-slate-700 dark:text-slate-300'}`;
                btn.textContent = category;
                btn.onclick = () => showEmojiCategory(category, btn);
                categoryContainer.appendChild(btn);
            });
            
            emojiPanel.appendChild(categoryContainer);
            
            // Create emoji grid container
            const emojiGrid = document.createElement('div');
            emojiGrid.id = 'emoji-grid';
            emojiGrid.className = 'grid grid-cols-8 gap-1 p-2';
            emojiPanel.appendChild(emojiGrid);
            
            // Show first category by default
            showEmojiCategory(Object.keys(emojiCategories)[0]);
            
            // Close emoji panel when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#emoji-panel') && !e.target.closest('#emoji-btn')) {
                    emojiPanel.classList.remove('active');
                }
            });
        }

        function showEmojiCategory(category, button = null) {
            // Update active button
            document.querySelectorAll('.emoji-category-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.classList.add('bg-slate-100', 'dark:bg-slate-700', 'text-slate-700', 'dark:text-slate-300');
            });
            
            if (button) {
                button.classList.add('active');
                button.classList.remove('bg-slate-100', 'dark:bg-slate-700', 'text-slate-700', 'dark:text-slate-300');
            }
            
            // Show emojis for category
            const emojiGrid = document.getElementById('emoji-grid');
            emojiGrid.innerHTML = '';
            
            emojiCategories[category].forEach(emoji => {
                const btn = document.createElement('button');
                btn.className = "hover:bg-slate-200 dark:hover:bg-slate-700 p-1.5 rounded text-xl transition-all flex items-center justify-center emoji hover:scale-110 active:scale-95";
                btn.textContent = emoji;
                btn.onclick = () => {
                    document.getElementById('textInput').value += emoji;
                    document.getElementById('textInput').focus();
                    toggleEmojis();
                };
                emojiGrid.appendChild(btn);
            });
        }

        function toggleEmojis() {
            const emojiPanel = document.getElementById('emoji-panel');
            emojiPanel.classList.toggle('active');
            
            // Update panel theme class
            if (document.documentElement.classList.contains('dark')) {
                emojiPanel.classList.add('dark');
                emojiPanel.classList.remove('light');
            } else {
                emojiPanel.classList.add('light');
                emojiPanel.classList.remove('dark');
            }
        }

        // Encryption Functions
        function initEncryption() {
            if (!ENCRYPTION_ENABLED) return;
            
            // Try to load existing key or generate new one
            const storedKey = localStorage.getItem(ENCRYPTION_KEY_STORAGE);
            if (storedKey) {
                encryptionKey = storedKey;
            } else {
                // Generate a new encryption key
                encryptionKey = generateEncryptionKey();
                localStorage.setItem(ENCRYPTION_KEY_STORAGE, encryptionKey);
            }
            
            console.log('Encryption initialized');
        }

        function generateEncryptionKey() {
            // Generate a random 32-character key
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';
            let key = '';
            for (let i = 0; i < 32; i++) {
                key += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return key;
        }

        function encryptMessage(text) {
            if (!ENCRYPTION_ENABLED || !encryptionKey) return text;
            
            try {
                // Simple XOR encryption for demonstration (in production, use stronger encryption)
                const encrypted = CryptoJS.AES.encrypt(text, encryptionKey).toString();
                return encrypted;
            } catch (error) {
                console.error('Encryption failed:', error);
                return text; // Fallback to plain text
            }
        }

        function decryptMessage(encryptedText) {
            if (!ENCRYPTION_ENABLED || !encryptionKey) return encryptedText;
            
            try {
                // Check if it looks like encrypted text (contains ciphertext structure)
                if (!encryptedText.includes('U2FsdGVkX1')) {
                    return encryptedText; // Probably not encrypted
                }
                
                const decrypted = CryptoJS.AES.decrypt(encryptedText, encryptionKey).toString(CryptoJS.enc.Utf8);
                return decrypted || encryptedText; // Return original if decryption fails
            } catch (error) {
                console.error('Decryption failed:', error);
                return encryptedText; // Return original text
            }
        }

        function toggleTheme() {
            const isDark = document.documentElement.classList.toggle('dark');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            document.getElementById('theme-icon').setAttribute('data-lucide', isDark ? 'sun' : 'moon');
            initIcons();
        }

        if (localStorage.getItem('theme') === 'dark') {
            document.documentElement.classList.add('dark');
            document.getElementById('theme-icon').setAttribute('data-lucide', 'sun');
            initIcons();
        }

        async function fetchIP() {
            try {
                const res = await fetch('https://api.ipify.org?format=json');
                const data = await res.json();
                document.getElementById('ip-display').textContent = data.ip;
            } catch (e) { document.getElementById('ip-display').textContent = "Unknown"; }
        }

        async function load() {
            try {
                const res = await fetch(`${WORKER_URL}?room=${room}`);
                const data = await res.json();
                const chat = document.getElementById('chat');
                const currentUser = document.getElementById('userInput').value.trim();
                
                if (data.length !== lastMessageCount) {
                    chat.innerHTML = data.map((m, idx) => {
                        const isMe = currentUser && m.user === currentUser;
                        // Decrypt message
                        const decryptedText = decryptMessage(m.text);
                        
                        // Process text to add emoji spacing
                        const processedText = decryptedText.replace(/([\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F700}-\u{1F77F}\u{1F780}-\u{1F7FF}\u{1F800}-\u{1F8FF}\u{1F900}-\u{1F9FF}\u{1FA00}-\u{1FA6F}\u{1FA70}-\u{1FAFF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}])/gu, '<span class="emoji">$1</span>');
                        
                        return `
                            <div class="flex flex-col ${isMe ? 'items-end' : 'items-start'} animate-in fade-in slide-in-from-bottom-2 duration-300">
                                <div class="flex items-center gap-2 mb-1 px-1">
                                    <span class="text-[10px] font-bold text-slate-500 uppercase">${m.user}</span>
                                    ${ENCRYPTION_ENABLED ? '<span class="encryption-indicator"><i data-lucide="lock" class="w-2 h-2"></i><span>E2E</span></span>' : ''}
                                </div>
                                <div class="message-bubble relative shadow-sm ${isMe 
                                    ? 'bg-emerald-600 text-white rounded-l-xl rounded-tr-xl' 
                                    : 'bg-white dark:bg-slate-800 text-slate-900 dark:text-slate-100 border border-slate-200 dark:border-slate-700 rounded-r-xl rounded-tl-xl'} px-4 py-2 text-sm message-text"
                                    onmousedown="startPress(event, '${idx}', ${isMe})" 
                                    ontouchstart="startPress(event, '${idx}', ${isMe})"
                                    onmouseup="endPress()" 
                                    ontouchend="endPress()">
                                    ${processedText}
                                    <div id="reactions-${idx}" class="absolute -bottom-2 ${isMe ? 'right-0' : 'left-0'} flex gap-1"></div>
                                </div>
                            </div>
                        `;
                    }).join('');
                    lastMessageCount = data.length;
                    scrollToBottom();
                }
            } catch (e) {}
        }

        async function send() {
            const now = Date.now();
            const timeSinceLastMessage = now - lastSentTime;
            
            // Check if cooldown is active
            if (timeSinceLastMessage < MESSAGE_COOLDOWN) {
                showRateLimitWarning(timeSinceLastMessage);
                return;
            }
            
            const user = document.getElementById('userInput').value.trim() || "Anonymous";
            let text = document.getElementById('textInput').value.trim();
            if (!text) return;
            
            // Encrypt message before sending
            if (ENCRYPTION_ENABLED) {
                text = encryptMessage(text);
            }
            
            localStorage.setItem('swiftchat_nick', user);
            try {
                await fetch(`${WORKER_URL}?room=${room}`, {
                    method: 'POST',
                    body: JSON.stringify({ user, text })
                });
                document.getElementById('textInput').value = '';
                lastSentTime = now;
                updateSendButtonState();
                load();
            } catch (e) {}
        }

        function showRateLimitWarning(timeSinceLastMessage) {
            const overlay = document.getElementById('rate-limit-overlay');
            const timeLeft = Math.ceil((MESSAGE_COOLDOWN - timeSinceLastMessage) / 1000);
            overlay.querySelector('.text-xs').textContent = `Wait ${timeLeft}s`;
            overlay.classList.remove('hidden');
            
            // Update countdown
            const interval = setInterval(() => {
                const currentTimeLeft = Math.ceil((MESSAGE_COOLDOWN - (Date.now() - lastSentTime)) / 1000);
                if (currentTimeLeft <= 0) {
                    overlay.classList.add('hidden');
                    clearInterval(interval);
                } else {
                    overlay.querySelector('.text-xs').textContent = `Wait ${currentTimeLeft}s`;
                }
            }, 1000);
            
            // Auto-hide after cooldown
            setTimeout(() => {
                overlay.classList.add('hidden');
                clearInterval(interval);
            }, MESSAGE_COOLDOWN - timeSinceLastMessage);
        }

        function updateSendButtonState() {
            const sendBtn = document.getElementById('send-btn');
            const timeSinceLastMessage = Date.now() - lastSentTime;
            
            if (timeSinceLastMessage < MESSAGE_COOLDOWN) {
                sendBtn.disabled = true;
                sendBtn.classList.add('opacity-50', 'cursor-not-allowed');
                sendBtn.classList.remove('hover:bg-blue-500');
                
                // Re-enable after cooldown
                setTimeout(() => {
                    sendBtn.disabled = false;
                    sendBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    sendBtn.classList.add('hover:bg-blue-500');
                }, MESSAGE_COOLDOWN - timeSinceLastMessage);
            }
        }

        function handleKeyPress(e) { 
            if (e.key === 'Enter') {
                e.preventDefault();
                send(); 
            }
        }
        
        function scrollToBottom() { 
            const chat = document.getElementById('chat'); 
            chat.scrollTo({ top: chat.scrollHeight, behavior: 'smooth' }); 
        }

        // Long Press Logic
        function startPress(e, id, isMe) {
            selectedMessageId = id;
            longPressTimer = setTimeout(() => {
                showContextMenu(e, isMe);
            }, 600);
        }

        function endPress() { 
            clearTimeout(longPressTimer); 
            // Close emoji panel if clicking elsewhere
            document.getElementById('emoji-panel').classList.remove('active');
        }

        function showContextMenu(e, isMe) {
            const menu = document.getElementById('context-menu');
            const deleteBtn = document.getElementById('delete-btn');
            const reactions = document.getElementById('reaction-tools');
            
            // Adjust menu based on ownership
            deleteBtn.style.display = isMe ? 'flex' : 'none';
            reactions.style.display = isMe ? 'none' : 'flex';

            menu.classList.add('active');
            const x = e.pageX || e.touches[0].pageX;
            const y = e.pageY || e.touches[0].pageY;
            menu.style.left = `${Math.min(x, window.innerWidth - 160)}px`;
            menu.style.top = `${Math.min(y, window.innerHeight - 100)}px`;
            
            // Close emoji panel
            document.getElementById('emoji-panel').classList.remove('active');
        }

        function addReaction(emoji) {
            const container = document.getElementById(`reactions-${selectedMessageId}`);
            const span = document.createElement('span');
            span.className = "bg-white dark:bg-slate-700 rounded-full px-1 py-0.5 text-[10px] shadow-sm border border-slate-100 dark:border-slate-600 animate-in zoom-in emoji";
            span.textContent = emoji;
            container.appendChild(span);
            closeMenu();
        }

        function deleteMessage() {
            // In a real app, send DELETE to server. Here we just hide it locally.
            const bubbles = document.querySelectorAll('.message-bubble');
            if (bubbles[selectedMessageId]) {
                bubbles[selectedMessageId].parentElement.remove();
            }
            closeMenu();
        }

        function closeMenu() { 
            document.getElementById('context-menu').classList.remove('active'); 
            // Also close emoji panel
            document.getElementById('emoji-panel').classList.remove('active');
        }
        
        document.addEventListener('click', (e) => { 
            if (!e.target.closest('#context-menu')) closeMenu(); 
        });

        // PWA Installation Logic
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            
            // Show install prompt after 5 seconds
            setTimeout(() => {
                if (deferredPrompt && !window.matchMedia('(display-mode: standalone)').matches) {
                    document.getElementById('pwa-prompt').classList.remove('hidden');
                }
            }, 5000);
        });

        function installPWA() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('PWA installed');
                    }
                    deferredPrompt = null;
                    document.getElementById('pwa-prompt').classList.add('hidden');
                });
            }
        }

        function dismissPWA() {
            document.getElementById('pwa-prompt').classList.add('hidden');
            localStorage.setItem('pwa_dismissed', 'true');
        }

        // Check if PWA is already installed
        if (window.matchMedia('(display-mode: standalone)').matches) {
            console.log('Running as PWA');
        } else if (localStorage.getItem('pwa_dismissed') === 'true') {
            // Don't show if user dismissed before
        }

        // Notifications & Welcome
        window.addEventListener('load', () => {
            if (Notification.permission !== 'granted') Notification.requestPermission();
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js').catch(err => {
                    console.log('Service Worker registration failed:', err);
                });
            }
            document.getElementById('userInput').value = localStorage.getItem('swiftchat_nick') || "";
            
            // Initialize encryption and emoji picker
            initEncryption();
            initEmojiPicker();
        });

        fetchIP();
        load();
        setInterval(load, 3000);
    </script>
</body>
</html>
